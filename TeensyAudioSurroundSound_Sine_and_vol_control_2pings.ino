//volume controlled by ultrasonic sensor.
//volume was working, but stopped whenever sine control was interjected...

//Ultrasonic Sensor SoftPing  https://bitbucket.org/teckel12/arduino-new-ping/wiki/Home
#include <NewPing.h>
#define MAX_DISTANCE 200 //in inches...max is 400-500cm
#define SONAR_NUM 2 //number of ping sensors
#define PING_PIN_A 14 //echo and trigger are combined
#define PING_PIN_B 20
#define PING_INTERVAL 50 //milliseconds between sensor pings (29ms is about the mid to avoid cross-sensor echo).
//unsigned long pingTimer[SONAR_NUM];
//unsigned int cm[SONAR_NUM];
//uint8_t currentSensor = 0;

//#define PING_PIN_B 15
//NewPing sonar[SONAR_NUM]  //NewPing setup of pins and max distance.  should be calling 0 and 1
NewPing sonar1(PING_PIN_A, PING_PIN_A, MAX_DISTANCE);  //sonar[1] for amplitude
NewPing sonar2(PING_PIN_B, PING_PIN_B, MAX_DISTANCE);  //sonar[2] for frequency

const unsigned int SECOND = 1000;
const unsigned int PING_CHECK_INTERVAL = SECOND / 1;  //how often the ultrasonic sensor is checked
unsigned long currentTime;
unsigned long nextTime = 0;
unsigned int rawSine2 = 0;
byte rawPing1 = 0;
byte rawPing2 = 0;
byte whichPing = 1;

//Teensy Audio System Design Tool
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>
AudioInputI2S Input;                      //xy=190,281
AudioSynthWaveformSineModulated sine_fm1;       //xy=366,288
AudioMixer4 mixer;                      //xy=406,197
AudioOutputI2S Output;                     //xy=547,292
AudioConnection patchCord1(Input, 1, mixer, 0);
AudioConnection patchCord2(sine_fm1, 0, mixer, 1);
AudioConnection patchCord3(mixer, 0, Output, 1);
AudioControlSGTL5000 audioShield;
//end autogenerated code
float vol = 0.5;
const float MAX_RAW_VOLUME = 20;
unsigned int raw_vol = 0;
unsigned int raw_interactive_vol = 0;


void setup() {
        AudioMemory(100); // detailed information, see the MemoryAndCpuUsage example
        audioShield.enable();
        audioShield.inputSelect(AUDIO_INPUT_MIC); // audioShield.inputSelect(AUDIO_INPUT_LINEIN);
//    pinMode(LED_BUILTIN, OUTPUT);
        Serial.begin(115200); //higher baud for ping
       //Serial1.begin(115200);
//sine_fm1.frequency(0);   //trying to initialize sine
//sine_fm1.amplitude(0.5);  //trying to initialize sine...causes volume control to stop working

}

void loop() {
        //Grab Ultrasonic sensor values and apply it to the frequency value

        currentTime = millis();
        if (currentTime >= nextTime) { //will always be true the first time...Timer incrememnter
                // Serial.println (nextTime);
                nextTime = currentTime + PING_CHECK_INTERVAL;
                if (whichPing ==1) {
                        whichPing = 2;
                        rawPing1 = sonar1.ping_in(); //raw ultrasonic value
                        Serial.print ("rawPing1=  ");
                        Serial.print (rawPing1);

                        //volume code interjected into the 1st ping loop
                        if (rawPing1 == 0 || rawPing1 > 25) { //if sensor is outside the detection range
                                raw_interactive_vol = MAX_RAW_VOLUME / 2;
                        }
                        else {
                                raw_interactive_vol = constrain(rawPing1, 1, MAX_RAW_VOLUME); //sonar = volume
                        }

                        if (raw_vol < raw_interactive_vol) { //ramp up/down to sensor volume
                                raw_vol += 1;
                        }
                        else if (raw_vol > raw_interactive_vol) {
                                raw_vol -= 1;
                        }
                        vol = raw_vol / MAX_RAW_VOLUME;
                        audioShield.volume(vol); //final sound output.  list here, and not in setup
                        Serial.print("   raw_interactive_vol=");
                        Serial.print(raw_interactive_vol);
                        Serial.print("   raw_vol=");
                        Serial.print(raw_vol);
                        Serial.print("   vol=");
                        Serial.print(vol);
                        //Serial1.println("vol");
                        //Serial1.println(vol);


                }
                //get values from ping 2
                else {
                        rawPing2 = sonar2.ping_in(); //raw ultrasonic value
                        Serial.print ("rawPing2=  ");
                        Serial.println (rawPing2);
                        whichPing = 1;

                        //sine generator interjected into 2nd ping check
                        if (rawPing2 >= 1 && rawPing2 <= 25) { //if sensor is triggered within the detection range
                                rawSine2 =  map(rawPing2, 0, 25, 4, 100);//map it to the frequency range desired...  could this be done on a logarithmic curve??
                                sine_fm1.frequency(rawSine2);
                                //sine_fm1.phase(0); //angle 0-360
                                Serial.print(" rawSine2= ");
                                Serial.println (rawSine2);
                                //Serial1.println("sin");
                                //Serial1.println(rawSine2);
                                sine_fm1.amplitude(1.0);  //Set the amplitude, from 0 to 1.0.
                        }
                        else {
                                rawSine2 = 0;
                        }
                }
        }

}
// if (currentTime >= nextTime)  {
//   nextTime = currentTime + PING_CHECK_INTERVAL;
//   rawPing2 = sonar2.ping_in();
//   Serial.print ("rawPing2=  ");
//   Serial.println (rawPing2);
//  }




//       if (rawPing == 0 or rawPing > 25) { //if sensor is triggered within the detection range
//        rawSine =  map(rawPing, 0, 25, 1, 50);  //map it to the frequency range desired...  could this be done on a logarithmic curve??
//                    sine_fm1.frequency(rawSine);  }
//         else {
//          rawSine = 0; }

//    if (raw_vol < raw_interactive_vol) {  //ramp up/down to sensor volume
//      raw_vol += 1; }
//        else if (raw_vol > raw_interactive_vol) {
//        raw_vol -= 1; }
//     sine_fm1.amplitude(0.5); //Set the amplitude, from 0 to 1.0.
////            //modSine =
////            sine_fm1.frequency(rawSine);
////
//     audioShield.volume(0.5);  //final sound output.  list here, and not in setup
//











/*

   sine_fm1.amplitude(level); //Set the amplitude, from 0 to 1.0.
   sine_fm1.frequency(freq);
   Set the center frequency, from 0 to 11000. The output will be this center frequency when the input modulation signal is zero.
   Modulation input 1.0 causes the frequency to double, and input -1.0 causes zero Hz (DC) output.
   For less modulation, attenuate the input signal (perhaps with a mixer object) before it arrives here.
   sine_fm1.phase(angle); 0-360
   Cause the generated waveform to jump to a specific point within its cycle. Angle is from 0 to 360 degrees.
   When multiple objects are configured, AudioNoInterrupts() should be used to guarantee all new settings take effect together.
 */

